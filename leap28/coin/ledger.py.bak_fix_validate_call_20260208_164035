"""
Complete Blockless Ledger System
Sharded across 5 segments for manageability

Hardened for validator/reserve use:
- deterministic shard mapping (sha256) instead of Python hash()
- canonical transaction id
- replay protection
- validation gate before state mutation
"""
from __future__ import annotations

import asyncio
import json
import logging
import hashlib
import time
from collections import defaultdict
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional

from .tx_validation import TxPolicy, compute_tx_id, stable_address_shard, validate_transaction, is_coinbase_tx

logger = logging.getLogger(__name__)


def _default_verify_signature(tx: Dict[str, Any]) -> bool:
    """
    Minimal hard default: require a signature field.
    Cryptographic verification should be injected by the node/consensus layer later.
    """
    sig = tx.get("signature")
    return isinstance(sig, str) and len(sig.strip()) > 0


class BlocklessLedger:
    """
    Blockless Ledger with Sharding

    No blockchain - just events with:
    - 5 shards for scalability
    - Balance tracking (account model)
    - Transaction history
    """

    def __init__(
        self,
        data_dir: str = "data/ledger",
        *,
        num_shards: int = 5,
        policy: Optional[TxPolicy] = None,
        verify_signature: Optional[Callable[[Dict[str, Any]], bool]] = None,
        require_signatures: bool = True,
    ):
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(parents=True, exist_ok=True)

        self.num_shards = int(num_shards)
        if self.num_shards <= 0:
            raise ValueError("num_shards must be positive")

        # Shards: each shard is an append-only JSONL file plus in-memory list
        self.shards: List[List[Dict[str, Any]]] = [[] for _ in range(self.num_shards)]

        # Balance tracking
        self.balances: defaultdict[str, int] = defaultdict(int)

        # Transaction index / replay protection
        self.transactions: Dict[str, Dict[str, Any]] = {}
        self._seen_tx_ids: set[str] = set()

        # Stats
        self.total_transactions = 0
        self.total_volume = 0

        # Canonical mint height (coinbase emission height)
        # HARDENED: LEDGER_MINT_HEIGHT_V1
        self.mint_height: int = 0
        # Issued supply (coinbase/mint only)
        self.issued_supply: int = 0

        # Policy + validation
        self.policy = policy or TxPolicy()
        self.require_signatures = bool(require_signatures)
        self.verify_signature = verify_signature or _default_verify_signature

        # In-process concurrency guard
        self._lock = asyncio.Lock()

    def get_shard_for_address(self, address: str) -> int:
        """Deterministic shard assignment (stable across runs / machines)."""
        return stable_address_shard(address, self.num_shards)

    def _seen_tx_lookup(self, tx_id: str) -> bool:
        return tx_id in self._seen_tx_ids

    def _current_balance_lookup(self, address: str) -> int:
        return int(self.balances.get(address, 0))

    def _normalize_tx(self, transaction: Dict[str, Any]) -> Dict[str, Any]:
        if not isinstance(transaction, dict):
            raise TypeError("transaction must be a dict")
        tx = dict(transaction)

        # timestamp hard default
        if "timestamp" not in tx or not isinstance(tx["timestamp"], int):
            tx["timestamp"] = int(time.time())

        # compute canonical id if missing
        computed_id = compute_tx_id(tx)
        provided_id = tx.get("id")
        if provided_id is None or provided_id == "":
            tx["id"] = computed_id
        elif str(provided_id) != computed_id:
            # If caller provided a mismatching id, normalize to canonical.
            # This avoids divergent ids across nodes.
            tx["id"] = computed_id

        return tx
    def _is_coinbase_tx(self, tx: Dict[str, Any]) -> bool:
        """
        HARDENED: DISABLE_DIRECT_MINT_V1

        Strict coinbase detector (single source of truth).
        Delegates to tx_validation.is_coinbase_tx (fail-closed, 3-signal identity).
        """
        try:
            return bool(is_coinbase_tx(tx))
        except Exception:
            return False



    async def add_transaction(self, transaction: Dict[str, Any]) -> bool:
        """
        Add transaction to ledger (validator safe)

        Enforces:
        - canonical tx id
        - replay protection
        - signature requirement (default on)
        - treasury spend blocked by policy (default on)
        - balance check (account model)
        """
        async with self._lock:
            try:
                tx = self._normalize_tx(transaction)

                # Validation gate
                # HARDENED: LEDGER_CANONICAL_HEIGHT_WIRE_V1
                # Canonical emission height is ledger-derived; miners do not control it.
                try:
                    if isinstance(tx, dict) and tx.get('sender') == 'COINBASE' and tx.get('type') == 'coinbase' and (tx.get('coinbase') is True):
                        tx['height'] = int(getattr(self, 'mint_height', 0))
                except Exception:
                    # fail-closed happens in validator if height lookup unavailable
                    pass
                ok, tx_id, reason = validate_transaction(
                    tx,
                    policy=self.policy,
                    current_balance_lookup=self._current_balance_lookup,
                    seen_tx_lookup=self._seen_tx_lookup,
                    verify_signature=(self.verify_signature if self.require_signatures else None),
                    current_height_lookup=(lambda: int(getattr(self, 'mint_height', 0))),
                    current_issued_lookup=(lambda: int(self.issued_supply)),
                    now_ts=int(time.time()),
                )

                if not ok:
                    logger.warning("❌ Reject tx id=%s reason=%s", tx_id or tx.get("id", ""), reason)
                    return False

                sender = str(tx["sender"])
                receiver = str(tx["receiver"])
                amount = int(tx["amount"])

                # Apply state
                is_coinbase = bool(is_coinbase_tx(tx))  # strict identity [HARDENED]
                if is_coinbase:
                    # [WIP] Coinbase/mint: credit-only (no sender debit)
                    self.balances[receiver] += amount
                    self.mint_height += 1  # canonical emission height advances on accepted mint
                    # [HARD] Track issued supply (coinbase/mint only)
                    self.issued_supply += int(amount)
                else:
                    # Normal transfer: debit + credit
                    self.balances[sender] -= amount
                    self.balances[receiver] += amount
                shard_id = self.get_shard_for_address(receiver if is_coinbase else sender)  # [WIP]
                self.shards[shard_id].append(tx)

                self.transactions[tx_id] = tx
                self._seen_tx_ids.add(tx_id)

                self.total_transactions += 1
                self.total_volume += amount

                await self._save_transaction(tx, shard_id)
                if is_coinbase:
                    logger.info("✅ Coinbase %s credited %s (+%s) shard=%s [WIP]", tx_id, receiver, amount, shard_id)
                else:
                    logger.info("✅ Transaction %s added to shard %s", tx_id, shard_id)
                return True

            except Exception as e:
                logger.exception("add_transaction failed: %s", e)
                return False

    def get_balance(self, address: str) -> int:
        """Get current balance for address"""
        return int(self.balances.get(address, 0))

    def get_transaction(self, tx_id: str) -> Optional[Dict[str, Any]]:
        """Get transaction by ID"""
        return self.transactions.get(tx_id)

    def get_transaction_history(self, address: str, limit: int = 100) -> List[Dict[str, Any]]:
        """
        Get transaction history for address.

        NOTE: We shard by sender, so receiver-side lookups require scanning.
        With 5 shards this is cheap and correct.
        """
        addr = str(address)
        history: List[Dict[str, Any]] = []
        for shard in self.shards:
            for tx in shard:
                if tx.get("sender") == addr or tx.get("receiver") == addr:
                    history.append(tx)

        history.sort(key=lambda x: int(x.get("timestamp", 0)), reverse=True)
        return history[: int(limit)]

    async def _save_transaction(self, transaction: Dict[str, Any], shard_id: int) -> None:
        """Persist transaction to disk"""
        shard_file = self.data_dir / f"shard_{int(shard_id)}.jsonl"
        with open(shard_file, "a", encoding="utf-8") as f:
            f.write(json.dumps(transaction, ensure_ascii=False) + "\n")

    async def load_from_disk(self) -> None:
        """
        Load ledger from disk on startup.

        Rebuilds:
        - shard lists
        - tx index
        - balances (account model replay)
        """
        async with self._lock:
            logger.info("Loading ledger from disk...")

            # reset in-memory
            self.shards = [[] for _ in range(self.num_shards)]
            self.balances = defaultdict(int)
            self.transactions = {}
            self._seen_tx_ids = set()
            self.total_transactions = 0
            self.total_volume = 0
            self.issued_supply = 0

            for shard_id in range(self.num_shards):
                shard_file = self.data_dir / f"shard_{shard_id}.jsonl"
                if not shard_file.exists():
                    continue

                with open(shard_file, "r", encoding="utf-8") as f:
                    for line in f:
                        if not line.strip():
                            continue
                        tx = json.loads(line)

                        # normalize + canonical id
                        tx = self._normalize_tx(tx)
                        tx_id = str(tx["id"])

                        # replay protection on disk duplicates
                        if tx_id in self._seen_tx_ids:
                            continue

                        self.shards[shard_id].append(tx)
                        self.transactions[tx_id] = tx
                        self._seen_tx_ids.add(tx_id)

                        sender = str(tx.get("sender", ""))
                        receiver = str(tx.get("receiver", ""))
                        amount = int(tx.get("amount", 0) or 0)
                        is_coinbase = self._is_coinbase_tx(tx)

                        if is_coinbase:
                            self.mint_height += 1  # canonical emission height rebuild
                        if is_coinbase:
                            self.issued_supply += int(amount)

                        # apply replay into balances
                        # coinbase-aware replay
                        if sender and (not is_coinbase):
                            self.balances[sender] -= amount
                        if receiver:
                            self.balances[receiver] += amount

                        self.total_transactions += 1
                        self.total_volume += amount

            logger.info("✅ Loaded %s transactions from disk", self.total_transactions)

    def get_ledger_stats(self) -> Dict[str, Any]:
        """Get ledger statistics"""
        return {
            "total_transactions": int(self.total_transactions),
            "total_volume": int(self.total_volume),
            "unique_addresses": int(len(self.balances)),
            "shards": int(self.num_shards),
            "transactions_per_shard": [len(shard) for shard in self.shards],
        }
    async def mint(self, receiver: str, amount: int, timestamp: int, network: str) -> bool:
        """
        HARDENED: DISABLE_DIRECT_MINT_V1

        Direct minting is disabled.
        Reason: the old mint() path bypassed validate_transaction() and could be used to exceed invariants.

        Protocol rule:
        - All issuance MUST be expressed as a STRICT coinbase tx and must pass tx_validation + supply cap.
        - Route issuance through consensus/ledger add_transaction() using sender='COINBASE', type='coinbase', coinbase=True.
        """
        raise RuntimeError('mint() disabled (hardening): use strict coinbase tx via consensus pipeline')

